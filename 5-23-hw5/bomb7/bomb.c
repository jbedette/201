//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2019 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4);
int64_t blank_line(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t driver_post(char * a1, char * a2, int64_t * a3, int64_t result2, int64_t * a5);
int64_t explode_bomb(void);
int64_t frame_dummy(void);
int64_t fun7(int64_t a1, int64_t a2);
int64_t func4(int64_t a1, int64_t a2, int64_t a3);
char * function_10b0(char * name);
int32_t function_10c0(char * s1, char * s2);
int32_t * function_10d0(void);
char * function_10e0(char * dest, char * src);
int32_t function_10f0(char * s);
int32_t function_1100(int32_t fd, int64_t * buf, int32_t n);
void function_1110(void);
int32_t function_1120(int32_t seconds);
int32_t function_1130(int32_t fd);
int32_t function_1140(int32_t fd, int64_t * buf, int32_t nbytes);
char * function_1150(char * s, int32_t n, struct _IO_FILE * stream);
void (*function_1160(int32_t sig, void (*handler)(int32_t)))(int32_t);
struct hostent * function_1170(char * name);
int64_t * function_1180(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen);
int32_t function_1190(char * nptr, char ** endptr, int32_t base);
int32_t function_11a0(struct _IO_FILE * stream);
int32_t function_11b0(char * s, char * format, ...);
int32_t function_11c0(int32_t flag, char * format, ...);
struct _IO_FILE * function_11d0(char * filename, char * modes);
int32_t function_11e0(char * name, int32_t len);
void function_11f0(int32_t status);
int32_t function_1200(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1210(struct _IO_FILE * stream, int32_t flag, char * format, ...);
int32_t function_1220(int32_t seconds);
int16_t ** function_1230(void);
int32_t function_1240(char * s, int32_t flag, int32_t slen, char * format, ...);
int32_t function_1250(int32_t domain, int32_t type, int32_t protocol);
void function_1260(int64_t * d);
int64_t init_driver(int64_t * a1);
int64_t init_timeout(int64_t a1);
int64_t initialize_bomb(void);
int64_t initialize_bomb_solve(void);
int64_t invalid_phase(int64_t a1);
int64_t phase_1(int64_t a1);
int64_t phase_2(int64_t a1);
int64_t phase_3(int64_t a1, int64_t a2, int64_t a3);
int64_t phase_4(int64_t str);
int64_t phase_5(int64_t str);
int64_t phase_6(int64_t a1);
int64_t phase_defused(void);
int64_t read_line(void);
int64_t read_six_numbers(int64_t str, int64_t * a2);
int64_t register_tm_clones(void);
int64_t rio_readlineb(int64_t a1, int64_t a2, int64_t a3);
int64_t secret_phase(void);
int64_t send_msg(int64_t a1);
int64_t sig_handler(void);
int64_t sigalrm_handler(void);
int64_t skip(void);
int64_t string_length(int64_t a1);
int64_t strings_not_equal(int64_t a1, char * a2);
int64_t submitr(char * a1, int64_t a2, char * a3, int64_t a4, int64_t a5, char * a6, int64_t a7, int64_t a8, int64_t a9);

// --------------------- Global Variables ---------------------

bool g1 = false; // df
int64_t g2 = 0x1370;
int64_t g3 = 0x1330;
int32_t g4 = 7;
int64_t g5 = 36;
int64_t g6 = 0x1000001f7;
char * g7[28] = {
    "adelie.cs.pdx.edu",
    "african.cs.pdx.edu",
    "chatham.cs.pdx.edu",
    "chinstrap.cs.pdx.edu",
    "dege.cs.pdx.edu",
    "emperor.cs.pdx.edu",
    "erect-crested.cs.pdx.edu",
    "fiordland.cs.pdx.edu",
    "galapagos.cs.pdx.edu",
    "gentoo.cs.pdx.edu",
    "humboldt.cs.pdx.edu",
    "icadyptes.cs.pdx.edu",
    "inguza.cs.pdx.edu",
    "kairuku.cs.pdx.edu",
    "king.cs.pdx.edu",
    "kororaa.cs.pdx.edu",
    "little.cs.pdx.edu",
    "macaroni.cs.pdx.edu",
    "magellanic.cs.pdx.edu",
    "perudyptes.cs.pdx.edu",
    "ptarmigan.cs.pdx.edu",
    "rockhopper.cs.pdx.edu",
    "royal.cs.pdx.edu",
    "snares.cs.pdx.edu",
    "waimanu.cs.pdx.edu",
    "white-flipper.cs.pdx.edu",
    "yellow-eyed.cs.pdx.edu",
    "zapdos.cs.pdx.edu"
};
char * g8[27] = {
    "african.cs.pdx.edu",
    "chatham.cs.pdx.edu",
    "chinstrap.cs.pdx.edu",
    "dege.cs.pdx.edu",
    "emperor.cs.pdx.edu",
    "erect-crested.cs.pdx.edu",
    "fiordland.cs.pdx.edu",
    "galapagos.cs.pdx.edu",
    "gentoo.cs.pdx.edu",
    "humboldt.cs.pdx.edu",
    "icadyptes.cs.pdx.edu",
    "inguza.cs.pdx.edu",
    "kairuku.cs.pdx.edu",
    "king.cs.pdx.edu",
    "kororaa.cs.pdx.edu",
    "little.cs.pdx.edu",
    "macaroni.cs.pdx.edu",
    "magellanic.cs.pdx.edu",
    "perudyptes.cs.pdx.edu",
    "ptarmigan.cs.pdx.edu",
    "rockhopper.cs.pdx.edu",
    "royal.cs.pdx.edu",
    "snares.cs.pdx.edu",
    "waimanu.cs.pdx.edu",
    "white-flipper.cs.pdx.edu",
    "yellow-eyed.cs.pdx.edu",
    "zapdos.cs.pdx.edu"
};
struct _IO_FILE * g9 = NULL;
int64_t g10 = 0;
struct _IO_FILE * g11 = NULL;
char g12 = 0;
int64_t g13 = 0;
int128_t g14;
int32_t g15 = 0;
char * g16;
char * g17;
int64_t g18 = -0x184100001864;
int64_t g19 = 0x20000000a;
int64_t g20 = 0x6000000090000;
int32_t g21 = 297;
int64_t g22 = 0x120000007a;
int64_t infile = 0;
int64_t g23 = 0; // r12
int64_t g24 = 0; // r13
int64_t g25 = 0; // rbp
int64_t g26 = 0; // rbx
int64_t g27 = 0; // rdi
int64_t g28 = 0; // rsi
int64_t g29 = 0; // rsp
int32_t g30;

// ------------------------ Functions -------------------------

// Address range: 0x1088 - 0x109f
int64_t _init(void) {
    // 0x1088
    int64_t result; // 0x109e
    if (*(int64_t *)0x203fe8 != 0) {
        // 0x1098
        __gmon_start__();
        result = &g30;
    } else {
        result = 0;
    }
    // 0x109a
    return result;
}

// Address range: 0x10b0 - 0x10b6
char * function_10b0(char * name) {
    // 0x10b0
    g27 = (int64_t)name;
    return getenv(name);
}

// Address range: 0x10c0 - 0x10c6
int32_t function_10c0(char * s1, char * s2) {
    // 0x10c0
    g28 = (int64_t)s2;
    g27 = (int64_t)s1;
    return strcasecmp(s1, s2);
}

// Address range: 0x10d0 - 0x10d6
int32_t * function_10d0(void) {
    // 0x10d0
    return __errno_location();
}

// Address range: 0x10e0 - 0x10e6
char * function_10e0(char * dest, char * src) {
    // 0x10e0
    g28 = (int64_t)src;
    g27 = (int64_t)dest;
    return strcpy(dest, src);
}

// Address range: 0x10f0 - 0x10f6
int32_t function_10f0(char * s) {
    // 0x10f0
    g27 = (int64_t)s;
    return puts(s);
}

// Address range: 0x1100 - 0x1106
int32_t function_1100(int32_t fd, int64_t * buf, int32_t n) {
    // 0x1100
    g28 = (int64_t)buf;
    g27 = fd;
    return write(fd, buf, n);
}

// Address range: 0x1110 - 0x1116
void function_1110(void) {
    // 0x1110
    __stack_chk_fail();
}

// Address range: 0x1120 - 0x1126
int32_t function_1120(int32_t seconds) {
    // 0x1120
    g27 = seconds;
    return alarm(seconds);
}

// Address range: 0x1130 - 0x1136
int32_t function_1130(int32_t fd) {
    // 0x1130
    g27 = fd;
    return close(fd);
}

// Address range: 0x1140 - 0x1146
int32_t function_1140(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x1140
    g28 = (int64_t)buf;
    g27 = fd;
    return read(fd, buf, nbytes);
}

// Address range: 0x1150 - 0x1156
char * function_1150(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1150
    g28 = n;
    g27 = (int64_t)s;
    return fgets(s, n, stream);
}

// Address range: 0x1160 - 0x1166
void (*function_1160(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x1160
    g28 = (int64_t)handler;
    g27 = sig;
    return signal(sig, handler);
}

// Address range: 0x1170 - 0x1176
struct hostent * function_1170(char * name) {
    // 0x1170
    g27 = (int64_t)name;
    return gethostbyname(name);
}

// Address range: 0x1180 - 0x1186
int64_t * function_1180(int64_t * dest, int64_t * src, int32_t len, int32_t dstlen) {
    // 0x1180
    g28 = (int64_t)src;
    g27 = (int64_t)dest;
    return __memmove_chk(dest, src, len, dstlen);
}

// Address range: 0x1190 - 0x1196
int32_t function_1190(char * nptr, char ** endptr, int32_t base) {
    // 0x1190
    g28 = (int64_t)endptr;
    g27 = (int64_t)nptr;
    return strtol(nptr, endptr, base);
}

// Address range: 0x11a0 - 0x11a6
int32_t function_11a0(struct _IO_FILE * stream) {
    // 0x11a0
    g27 = (int64_t)stream;
    return fflush(stream);
}

// Address range: 0x11b0 - 0x11b6
int32_t function_11b0(char * s, char * format, ...) {
    // 0x11b0
    g28 = (int64_t)format;
    g27 = (int64_t)s;
    return sscanf(s, format);
}

// Address range: 0x11c0 - 0x11c6
int32_t function_11c0(int32_t flag, char * format, ...) {
    // 0x11c0
    g28 = (int64_t)format;
    g27 = flag;
    return __printf_chk(flag, format);
}

// Address range: 0x11d0 - 0x11d6
struct _IO_FILE * function_11d0(char * filename, char * modes) {
    // 0x11d0
    g28 = (int64_t)modes;
    g27 = (int64_t)filename;
    return fopen(filename, modes);
}

// Address range: 0x11e0 - 0x11e6
int32_t function_11e0(char * name, int32_t len) {
    // 0x11e0
    g28 = len;
    g27 = (int64_t)name;
    return gethostname(name, len);
}

// Address range: 0x11f0 - 0x11f6
void function_11f0(int32_t status) {
    // 0x11f0
    g27 = status;
    exit(status);
}

// Address range: 0x1200 - 0x1206
int32_t function_1200(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1200
    g28 = (int64_t)addr;
    g27 = fd;
    return connect(fd, addr, len);
}

// Address range: 0x1210 - 0x1216
int32_t function_1210(struct _IO_FILE * stream, int32_t flag, char * format, ...) {
    // 0x1210
    g28 = flag;
    g27 = (int64_t)stream;
    return __fprintf_chk(stream, flag, format);
}

// Address range: 0x1220 - 0x1226
int32_t function_1220(int32_t seconds) {
    // 0x1220
    g27 = seconds;
    return sleep(seconds);
}

// Address range: 0x1230 - 0x1236
int16_t ** function_1230(void) {
    // 0x1230
    return __ctype_b_loc();
}

// Address range: 0x1240 - 0x1246
int32_t function_1240(char * s, int32_t flag, int32_t slen, char * format, ...) {
    // 0x1240
    g28 = flag;
    g27 = (int64_t)s;
    return __sprintf_chk(s, flag, slen, format);
}

// Address range: 0x1250 - 0x1256
int32_t function_1250(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1250
    g28 = type;
    g27 = domain;
    return socket(domain, type, protocol);
}

// Address range: 0x1260 - 0x1266
void function_1260(int64_t * d) {
    // 0x1260
    g27 = (int64_t)d;
    __cxa_finalize(d);
}

// Address range: 0x1270 - 0x129b
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    // 0x1270
    g28 = a2;
    g27 = a1;
    g28 = a4;
    g27 = 0x137a;
    int64_t v1;
    __libc_start_main(0x137a, (int32_t)a4, (char **)&v1, (void (*)())0x2be0, (void (*)())0x2c50, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x12a0 - 0x12d2
int64_t deregister_tm_clones(void) {
    // 0x12a0
    g27 = (int64_t)&g9;
    return (int64_t)&g9;
}

// Address range: 0x12e0 - 0x1322
int64_t register_tm_clones(void) {
    // 0x1320
    g27 = (int64_t)&g9;
    g28 = 0;
    return 0;
}

// Address range: 0x1330 - 0x136a
int64_t __do_global_dtors_aux(void) {
    // 0x1330
    if (g12 != 0) {
        // 0x1368
        int64_t result; // rax
        return result;
    }
    if (*(int64_t *)0x203ff8 != 0) {
        int64_t v1 = *(int64_t *)0x204008; // 0x1347
        g27 = v1;
        __cxa_finalize((int64_t *)v1);
    }
    // 0x1353
    g12 = 1;
    return deregister_tm_clones();
}

// Address range: 0x1370 - 0x137a
int64_t frame_dummy(void) {
    // 0x1370
    return register_tm_clones();
}

// From module:   /home/karavan/lab201/bomblab/src/bomb.c
// Address range: 0x137a - 0x14d4
// Line range:    36 - 63
int main(int argc, char ** argv) {
    // 0x137a
    g28 = (int64_t)argv;
    g27 = argc;
    int32_t v1 = g27; // 0x137b
    if (v1 == 1) {
        // 0x147c
        infile = g10;
    } else {
        int64_t v2 = g28; // 0x1384
        g26 = v2;
        if (v1 != 2) {
            // 0x14b1
            g28 = (int64_t)"Usage: %s [<input_file>]\n";
            g27 = 1;
            __printf_chk(1, "Usage: %s [<input_file>]\n", (char *)v2);
            g27 = 8;
            exit(8);
            return &g30;
        }
        int64_t file_path = *(int64_t *)(v2 + 8); // 0x1390
        g27 = file_path;
        g28 = (int64_t)"r";
        struct _IO_FILE * file = fopen((char *)file_path, "r"); // 0x139b
        infile = (int64_t)file;
        if (file == NULL) {
            // 0x148f
            g28 = (int64_t)"%s: Error: Couldn't open %s\n";
            g27 = 1;
            __printf_chk(1, "%s: Error: Couldn't open %s\n", "r", (char *)*(int64_t *)(g26 + 8));
            g27 = 8;
            exit(8);
            // UNREACHABLE
        }
    }
    // 0x13b0
    initialize_bomb();
    g27 = (int64_t)"Welcome to my fiendish little bomb. You have 6 phases with";
    puts("Welcome to my fiendish little bomb. You have 6 phases with");
    g27 = (int64_t)"which to blow yourself up. Have a nice day!";
    puts("which to blow yourself up. Have a nice day!");
    int64_t v3 = read_line(); // 0x13cd
    g27 = v3;
    phase_1(v3);
    phase_defused();
    g27 = (int64_t)"Phase 1 defused. How about the next one?";
    puts("Phase 1 defused. How about the next one?");
    int64_t v4 = read_line(); // 0x13eb
    g27 = v4;
    phase_2(v4);
    phase_defused();
    g27 = (int64_t)"That's number 2.  Keep going!";
    puts("That's number 2.  Keep going!");
    g27 = read_line();
    phase_3((int64_t)&g30, (int64_t)&g30, (int64_t)&g30);
    phase_defused();
    g27 = (int64_t)"Halfway there!";
    puts("Halfway there!");
    int64_t v5 = read_line(); // 0x1427
    g27 = v5;
    phase_4(v5);
    phase_defused();
    g27 = (int64_t)"So you got that one.  Try this one.";
    puts("So you got that one.  Try this one.");
    int64_t v6 = read_line(); // 0x1445
    g27 = v6;
    phase_5(v6);
    phase_defused();
    g27 = (int64_t)"Good work!  On to the next...";
    puts("Good work!  On to the next...");
    int64_t v7 = read_line(); // 0x1463
    g27 = v7;
    phase_6(v7);
    phase_defused();
    return 0;
}

// Address range: 0x14d4 - 0x14f4
int64_t phase_1(int64_t a1) {
    // 0x14d4
    g27 = a1;
    g28 = (int64_t)"Border relations with Canada have never been better.";
    int64_t result = strings_not_equal(a1, "Border relations with Canada have never been better."); // 0x14df
    if ((int32_t)result == 0) {
        // 0x14e8
        return result;
    }
    // 0x14ed
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x14f4 - 0x1562
int64_t phase_2(int64_t a1) {
    // 0x14f4
    g27 = a1;
    int64_t v1 = g25; // 0x14f4
    int64_t v2 = g26; // 0x14f5
    int32_t v3; // bp-56
    int64_t v4 = &v3; // 0x14f6
    int64_t v5 = __readfsqword(40); // 0x14fa
    g28 = v4;
    read_six_numbers(a1, (int64_t *)&v3);
    if (v3 < 0) {
        // 0x1522
        explode_bomb();
        // UNREACHABLE
    }
    // 0x1518
    g26 = 1;
    g25 = v4;
    int64_t v6 = 1; // 0x1529
    while (true) {
        int64_t v7 = 4 * v6; // 0x1535
        int32_t v8 = *(int32_t *)(v4 - 4 + v7); // 0x1535
        if (*(int32_t *)(v7 + v4) != v8 + (int32_t)v6) {
            // break -> 0x153f
            break;
        }
        int64_t v9 = v6 + 1; // 0x1529
        g26 = v9;
        if (v6 == 5) {
            int64_t result = __readfsqword(40) ^ v5; // 0x154b
            if (result != 0) {
                // 0x155d
                __stack_chk_fail();
                return &g30;
            }
            // 0x1556
            g26 = v2;
            g25 = v1;
            return result;
        }
        v6 = v9;
    }
    // 0x153f
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x1562 - 0x16d5
int64_t phase_3(int64_t a1, int64_t a2, int64_t a3) {
    // 0x1562
    __readfsqword(40);
    g28 = (int64_t)"%d %c %d";
    int64_t v1; // bp-20
    int32_t v2; // bp-24
    int64_t v3; // bp-25
    if (sscanf((char *)g27, "%d %c %d", &v2, &v3, &v1) <= 2) {
        // 0x15b5
        explode_bomb();
        // UNREACHABLE
    }
    if (v2 < 8) {
        int32_t v4 = *(int32_t *)(4 * (int64_t)v2 + (int64_t)&g18); // 0x15ac
        return (int64_t)v4 + (int64_t)&g18;
    }
    // 0x16a6
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x16d5 - 0x1714
int64_t func4(int64_t a1, int64_t a2, int64_t a3) {
    // 0x16d5
    g28 = a2;
    g27 = a1;
    int32_t v1 = a2; // 0x16db
    int32_t v2 = (int32_t)a3 - v1; // 0x16db
    int64_t v3 = ((int32_t)(v2 < 0) + v2) / 2 + v1; // 0x16e6
    if (v3 > a1) {
        // 0x16f5
        return 2 * func4(a1, a2, v3 - 1) & 0xfffffffe;
    }
    int64_t result; // 0x16f9
    if (v3 < a1) {
        int64_t v4 = v3 + 1; // 0x1706
        g28 = v4;
        result = 2 * func4(a1, v4, a3) | 1;
    } else {
        result = 0;
    }
    // 0x16f5
    return result;
}

// Address range: 0x1714 - 0x1789
int64_t phase_4(int64_t str) {
    // 0x1714
    g27 = str;
    int64_t v1 = __readfsqword(40); // 0x1718
    g28 = (int64_t)"%d %d";
    int32_t v2; // bp-20
    int32_t v3; // bp-24
    if (sscanf((char *)str, "%d %d", &v3, &v2) != 2 || v3 >= 15) {
        // 0x1747
        explode_bomb();
        // UNREACHABLE
    }
    // 0x174c
    g28 = 0;
    int64_t v4 = v3; // 0x1756
    g27 = v4;
    if ((int32_t)func4(v4, 0, 14) != 2 || v2 != 2) {
        // 0x176a
        explode_bomb();
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1774
    if (result == 0) {
        // 0x177f
        return result;
    }
    // 0x1784
    __stack_chk_fail();
    return &g30;
}

// Address range: 0x1789 - 0x181c
int64_t phase_5(int64_t str) {
    // 0x1789
    g27 = str;
    int64_t v1 = __readfsqword(40); // 0x178d
    g28 = (int64_t)"%d %d";
    int32_t v2; // bp-20
    int32_t v3; // bp-24
    if (sscanf((char *)str, "%d %d", &v3, &v2) <= 1) {
        // 0x1810
        explode_bomb();
        // UNREACHABLE
    }
    int32_t v4 = v3 % 16; // 0x17b9
    v3 = v4;
    if (v4 == 15) {
        // 0x17f6
        explode_bomb();
        // UNREACHABLE
    }
    // 0x17c4
    g28 = &g19;
    int64_t v5 = 1; // 0x17d5
    int32_t v6 = *(int32_t *)(4 * (int64_t)v4 + (int64_t)&g19); // 0x17da
    int32_t v7 = v6; // 0x17dd
    while (v6 != 15) {
        // 0x17d5
        v5 = (v5 & 0xffffffff) + 1;
        v6 = *(int32_t *)(4 * (int64_t)v6 + (int64_t)&g19);
        v7 += v6;
    }
    // 0x17e4
    v3 = 15;
    if ((int32_t)v5 != 15 || v2 != v7) {
        // 0x17f6
        explode_bomb();
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1800
    if (result == 0) {
        // 0x180b
        return result;
    }
    // 0x1817
    __stack_chk_fail();
    return &g30;
}

// Address range: 0x181c - 0x193e
int64_t phase_6(int64_t a1) {
    // 0x181c
    g27 = a1;
    int64_t v1 = g25; // 0x1820
    int64_t v2 = g26; // 0x1821
    int64_t v3; // bp-136
    int64_t v4 = &v3; // 0x1822
    int64_t v5 = __readfsqword(40); // 0x1826
    g23 = v4;
    g28 = v4;
    read_six_numbers(a1, &v3);
    int64_t v6 = g23;
    g25 = v6;
    int32_t * v7 = (int32_t *)v6; // 0x187174
    if (*v7 >= 7) {
        // 0x1849
        explode_bomb();
        // UNREACHABLE
    }
    int64_t v8 = 0;
    while (true) {
        int64_t v9 = v8 + 1;
        if (v8 == 5) {
            // break -> 0x18bc
            break;
        }
        // 0x1887
        g26 = v9;
        int64_t v10 = v9; // 0x1850
        while (true) {
            // 0x1858
            if (*v7 == *(int32_t *)(4 * v10 + g29)) {
                // 0x1863
                explode_bomb();
                // UNREACHABLE
            }
            int32_t v11 = (int32_t)v10 + 1; // 0x1850
            int64_t v12 = v11; // 0x1850
            g26 = v12;
            if (v11 > 5) {
                // break -> 0x186a
                break;
            }
            v10 = v12;
        }
        int64_t v13 = v6 + 4; // 0x186a
        g25 = v13;
        int32_t * v14 = (int32_t *)v13; // 0x1871
        if (*v14 >= 7) {
            // 0x1849
            explode_bomb();
            // UNREACHABLE
        }
        v8 = v9;
        v7 = v14;
        v6 = v13;
    }
    // 0x18bc
    g28 = 0;
    int64_t v15 = 0; // 0x1897
    int64_t v16; // rax
    while (true) {
        int32_t v17 = *(int32_t *)(4 * v15 + g29); // 0x18a6
        v16 = 1;
        int64_t v18; // 0x1897
        if (v17 > 1) {
            int64_t v19 = *(int64_t *)((int64_t)&g6 + 8); // 0x188c
            int32_t v20 = 2; // 0x1890
            v16 = v20;
            v18 = v19;
            while (v20 != v17) {
                // 0x188c
                v19 += 8;
                v20++;
                v16 = v20;
                v18 = v19;
            }
        } else {
            v18 = &g6;
        }
        // 0x1897
        *(int64_t *)(g29 + 32 + 8 * v15) = v18;
        int64_t v21 = g28; // 0x189c
        int64_t v22 = v21 + 1; // 0x189c
        g28 = v22;
        if (v21 == 5) {
            // break -> 0x18c3
            break;
        }
        v15 = v22;
    }
    // 0x18c3
    int32_t * v23;
    g26 = (int64_t)v23;
    *(int64_t *)(v16 + 8) = 0;
    g25 = 5;
    int64_t v24 = 5;
    int64_t v25 = g26; // 0x1904
    while (true) {
        int64_t * v26 = (int64_t *)(v25 + 8); // 0x190d
        if ((int64_t)*(int32_t *)v25 > (int64_t)*(int32_t *)*v26) {
            // break -> 0x1917
            break;
        }
        int64_t v27 = *v26; // 0x1904
        g26 = v27;
        int64_t v28 = v24 - 1;
        g25 = v28;
        if (v28 == 0) {
            int64_t result = __readfsqword(40) ^ v5; // 0x1923
            if (result != 0) {
                // 0x1939
                __stack_chk_fail();
                return &g30;
            }
            // 0x192e
            g26 = v2;
            g25 = v1;
            return result;
        }
        v24 = v28;
        v25 = v27;
    }
    // 0x1917
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x193e - 0x197d
int64_t fun7(int64_t a1, int64_t a2) {
    // 0x193e
    g28 = a2;
    g27 = a1;
    if (a1 == 0) {
        // 0x1977
        return 0xffffffff;
    }
    uint32_t v1 = *(int32_t *)&g27; // 0x1947
    if ((int64_t)v1 > a2) {
        int64_t v2 = *(int64_t *)(a1 + 8); // 0x195b
        g27 = v2;
        // 0x1956
        return 2 * fun7(v2, a2) & 0xfffffffe;
    }
    int64_t result; // 0x195a
    if (v1 != (int32_t)a2) {
        int64_t v3 = *(int64_t *)(a1 + 16); // 0x1968
        g27 = v3;
        result = 2 * fun7(v3, a2) | 1;
    } else {
        result = 0;
    }
    // 0x1956
    return result;
}

// Address range: 0x197d - 0x19d5
int64_t secret_phase(void) {
    int64_t v1 = g26; // 0x197d
    int64_t str = read_line(); // 0x197e
    g28 = 0;
    g27 = str;
    int32_t str_as_l = strtol((char *)str, NULL, 10); // 0x1990
    int64_t v2 = str_as_l; // 0x1990
    g26 = v2;
    if (str_as_l - 1 > (int32_t)&g21) {
        // 0x19c7
        explode_bomb();
        // UNREACHABLE
    }
    // 0x19a2
    g28 = v2;
    g27 = &g5;
    if ((int32_t)fun7((int64_t)&g5, v2) != 0) {
        // 0x19ce
        explode_bomb();
        // UNREACHABLE
    }
    // 0x19b4
    g27 = (int64_t)"Wow! You've defused the secret stage!";
    puts("Wow! You've defused the secret stage!");
    int64_t result = phase_defused(); // 0x19c0
    g26 = v1;
    return result;
}

// Address range: 0x19d5 - 0x1a31
int64_t sig_handler(void) {
    // 0x19d5
    g27 = (int64_t)"So you think you can stop the bomb with ctrl-c, do you?";
    puts("So you think you can stop the bomb with ctrl-c, do you?");
    g27 = 3;
    sleep(3);
    g28 = (int64_t)"Well...";
    g27 = 1;
    __printf_chk(1, "Well...");
    struct _IO_FILE * stream = g9; // 0x1a05
    g27 = (int64_t)stream;
    fflush(stream);
    g27 = 1;
    sleep(1);
    g27 = (int64_t)"OK. :-)";
    puts("OK. :-)");
    g27 = 16;
    exit(16);
    return &g30;
}

// Address range: 0x1a31 - 0x1a58
int64_t invalid_phase(int64_t a1) {
    // 0x1a31
    g27 = a1;
    int64_t v1 = g27; // 0x1a35
    g28 = (int64_t)"Invalid phase%s\n";
    g27 = 1;
    __printf_chk(1, "Invalid phase%s\n", (char *)v1);
    g27 = 8;
    exit(8);
    return &g30;
}

// Address range: 0x1a58 - 0x1a75
int64_t string_length(int64_t a1) {
    // 0x1a58
    g27 = a1;
    if ((char)a1 == 0) {
        // 0x1a6f
        return 0;
    }
    int64_t v1 = a1 + 1; // 0x1a60
    while (*(char *)v1 != 0) {
        // 0x1a60
        v1++;
    }
    // 0x1a6d
    return v1 - a1 & 0xffffffff;
}

// Address range: 0x1a75 - 0x1adc
int64_t strings_not_equal(int64_t a1, char * a2) {
    // 0x1a75
    g28 = (int64_t)a2;
    g27 = a1;
    int64_t v1 = g26; // 0x1a78
    int64_t v2 = g28; // 0x1a7c
    int64_t v3 = string_length(a1); // 0x1a7f
    g27 = v2;
    if ((int32_t)v3 != (int32_t)string_length(v2)) {
        // 0x1a99
        g26 = v1;
        return 1;
    }
    char v4 = *(char *)&g27; // 0x1aa0
    if (v4 == 0) {
        // 0x1a99
        g26 = v1;
        return 0;
    }
    // 0x1aa7
    if (v4 != *(char *)&g28) {
        // 0x1a99
        g26 = v1;
        return 1;
    }
    int64_t result; // 0x1a99
    while (true) {
        int64_t v5 = a1 + 1; // 0x1aac
        int64_t v6 = v2 + 1; // 0x1ab0
        char v7 = *(char *)v5; // 0x1ab4
        if (v7 == 0) {
            // break -> 0x1ac7
            break;
        }
        // 0x1abb
        if (*(char *)v6 != v7) {
            result = 1;
            goto lab_0x1a99;
        }
        v2 = v6;
        a1 = v5;
    }
    result = 0;
  lab_0x1a99:
    // 0x1a99
    g26 = v1;
    return result;
}

// Address range: 0x1adc - 0x1bca
int64_t initialize_bomb(void) {
    int64_t v1 = g25; // 0x1adc
    int64_t v2 = g26; // 0x1add
    int64_t name; // bp-8296
    int64_t v3 = &name; // 0x1ade
    int64_t v4 = __readfsqword(40); // 0x1ae5
    g28 = 0x19d5;
    g27 = 2;
    signal(SIGINT, 0x19d5);
    g27 = v3;
    g28 = 64;
    if (gethostname((char *)&name, 64) != 0) {
        // 0x1b5f
        g27 = (int64_t)"Initialization error: Running on an illegal host [1]";
        puts("Initialization error: Running on an illegal host [1]");
        g27 = 8;
        exit(8);
        // UNREACHABLE
    }
    int64_t str = *(int64_t *)&g7; // 0x1b1a
    g27 = str;
    g26 = (int64_t)&g8;
    g25 = v3;
    if (str == 0) {
        // 0x1b49
        g27 = (int64_t)"Initialization error: Running on an illegal host [2]";
        puts("Initialization error: Running on an illegal host [2]");
        g27 = 8;
        exit(8);
        // UNREACHABLE
    }
    while (true) {
        // 0x1b30
        g28 = v3;
        if (strcasecmp((char *)str, (char *)&name) == 0) {
            // break -> 0x1b9a
            break;
        }
        int64_t v5 = g26; // 0x1b3c
        g26 = v5 + 8;
        int64_t v6 = *(int64_t *)v5; // 0x1b40
        g27 = v6;
        if (v6 == 0) {
            // 0x1b49
            g27 = (int64_t)"Initialization error: Running on an illegal host [2]";
            puts("Initialization error: Running on an illegal host [2]");
            g27 = 8;
            exit(8);
            // UNREACHABLE
        }
        str = v6;
    }
    // 0x1b9a
    int64_t v7; // bp-8232
    g27 = &v7;
    if ((int32_t)init_driver(&v7) < 0) {
        // 0x1b75
        g28 = (int64_t)"Initialization error:\n%s\n";
        g27 = 1;
        __printf_chk(1, "Initialization error:\n%s\n", &v7);
        g27 = 8;
        exit(8);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v4; // 0x1bb0
    if (result != 0) {
        // 0x1bc5
        __stack_chk_fail();
        return &g30;
    }
    // 0x1bbb
    g26 = v2;
    g25 = v1;
    return result;
}

// Address range: 0x1bca - 0x1bcc
int64_t initialize_bomb_solve(void) {
    // 0x1bca
    int64_t result; // rax
    return result;
}

// Address range: 0x1bcc - 0x1c07
int64_t blank_line(int64_t a1) {
    // 0x1bcc
    g27 = a1;
    int64_t v1 = g27; // 0x1bd2
    int64_t result;
    while (true) {
        unsigned char v2 = *(char *)v1; // 0x1bd5
        if (v2 == 0) {
            result = 1;
            // break -> 0x1c00
            break;
        }
        int16_t ** v3 = __ctype_b_loc(); // 0x1bdd
        if ((*(char *)(*(int64_t *)v3 + 1 + 2 * (int64_t)v2) & 32) == 0) {
            result = 0;
            // break -> 0x1c00
            break;
        }
        v1++;
    }
    // 0x1c00
    return result;
}

// Address range: 0x1c07 - 0x1c55
int64_t skip(void) {
    int64_t v1 = g25; // 0x1c07
    int64_t v2 = g26; // 0x1c08
    g25 = (int64_t)&g16;
    int64_t v3 = (int64_t)&g16; // 0x1c23
    int64_t result; // 0x1c4b
    while (true) {
        int64_t str2 = 80 * (int64_t)*(int32_t *)&g14 + v3; // 0x1c23
        g27 = str2;
        g28 = 80;
        char * str = fgets((char *)str2, 80, (struct _IO_FILE *)infile); // 0x1c32
        int64_t v4 = (int64_t)str; // 0x1c32
        g26 = v4;
        if (str == NULL) {
            result = v4;
            // break -> 0x1c4b
            break;
        }
        // 0x1c3f
        g27 = v4;
        if ((int32_t)blank_line(v4) == 0) {
            // 0x1c3f
            result = g26;
            goto lab_0x1c4b;
        }
        // 0x1c3f
        v3 = g25;
    }
  lab_0x1c4b:
    // 0x1c4b
    g26 = v2;
    g25 = v1;
    return result;
}

// Address range: 0x1c55 - 0x1d79
int64_t send_msg(int64_t a1) {
    // 0x1c55
    g27 = a1;
    int64_t v1 = g26; // 0x1c55
    int64_t v2; // bp-16408
    int64_t v3 = &v2; // 0x1c56
    int64_t v4 = g27; // 0x1c5d
    int64_t v5 = __readfsqword(40); // 0x1c60
    int64_t v6 = (int64_t)*(int32_t *)&g14; // 0x1c73
    g28 = v6;
    g27 = 16 * ((int64_t)&g13 + 4 * (int64_t)&g13) + (int64_t)&g16;
    int64_t v7 = 16 * ((int64_t)&g13 + 4 * (int64_t)&g13) + (int64_t)&g16; // 0x1c9f
    int64_t v8 = -1; // 0x1c9f
    int64_t v9; // 0x1ca1
    while (true) {
        if (v8 == 0) {
            v9 = 0;
            // break -> bb48
            break;
        }
        int64_t v10 = (g1 ? -1 : 1) + v7; // 0x1c9f
        g27 = v10;
        int64_t v11 = v8 - 1; // 0x1c9f
        if (*(char *)v7 == 0) {
            v9 = v11;
            // break -> bb48
            break;
        }
        v7 = v10;
        v8 = v11;
    }
    if (-v9 >= 0x1f9f) {
        // 0x1d3d
        g28 = (int64_t)"ERROR: Input string is too large.";
        g27 = 1;
        __printf_chk(1, "ERROR: Input string is too large.");
        g27 = 8;
        exit(8);
        // UNREACHABLE
    }
    char * v12 = (int32_t)v4 == 0 ? "exploded" : "defused"; // 0x1cc8
    g26 = v3;
    g28 = 1;
    g27 = v3;
    __sprintf_chk((char *)&v2, 1, 0x2000, "%d:%s:%d:%s", (int64_t)g4, v12, v6, (char *)(16 * ((int64_t)&g13 + 4 * (int64_t)&g13) + (int64_t)&g16));
    g28 = (int64_t)"3FEUHCLVR7I32ejEDX2n";
    g27 = (int64_t)"jbedette";
    int64_t str; // bp-8216
    int64_t v13 = driver_post("jbedette", "3FEUHCLVR7I32ejEDX2n", &v2, 0, &str); // 0x1d14
    if ((int32_t)v13 < 0) {
        // 0x1d5d
        g27 = &str;
        puts((char *)&str);
        g27 = 0;
        exit(0);
        // UNREACHABLE
    }
    int64_t result = __readfsqword(40) ^ v5; // 0x1d29
    if (result != 0) {
        // 0x1d74
        __stack_chk_fail();
        return &g30;
    }
    // 0x1d34
    g26 = v1;
    return result;
}

// Address range: 0x1d79 - 0x1db5
int64_t explode_bomb(void) {
    // 0x1d79
    g27 = (int64_t)"\nBOOM!!!";
    puts("\nBOOM!!!");
    g27 = (int64_t)"The bomb has blown up.";
    puts("The bomb has blown up.");
    g27 = 0;
    send_msg(0);
    g27 = (int64_t)"Your instructor has been notified.";
    puts("Your instructor has been notified.");
    g27 = 8;
    exit(8);
    return &g30;
}

// Address range: 0x1db5 - 0x1df6
int64_t read_six_numbers(int64_t str, int64_t * a2) {
    // 0x1db5
    g28 = (int64_t)a2;
    g27 = str;
    int64_t v1 = g28; // 0x1db9
    g28 = (int64_t)"%d %d %d %d %d %d";
    int32_t items_assigned = sscanf((char *)str, "%d %d %d %d %d %d", (int64_t *)v1, (int64_t *)(v1 + 4), (int64_t *)(v1 + 8), (int64_t *)(v1 + 12), (int64_t *)(v1 + 16), (int64_t *)(v1 + 20)); // 0x1dde
    if (items_assigned > 5) {
        // 0x1dec
        return items_assigned;
    }
    // 0x1df1
    return explode_bomb();
}

// Address range: 0x1df6 - 0x1f3a
int64_t read_line(void) {
    // 0x1df6
    if (skip() == 0) {
        // 0x1e78
        if (infile == g10) {
            // 0x1ea3
            g27 = (int64_t)"Error: Premature EOF on stdin";
            puts("Error: Premature EOF on stdin");
            g27 = 8;
            exit(8);
            // UNREACHABLE
        }
        // 0x1e88
        g27 = (int64_t)"GRADE_BOMB";
        if (getenv("GRADE_BOMB") != NULL) {
            // 0x1e99
            g27 = 0;
            exit(0);
            // UNREACHABLE
        }
        // 0x1eb9
        infile = g10;
        if (skip() == 0) {
            // 0x1eda
            g27 = (int64_t)"Error: Premature EOF on stdin";
            puts("Error: Premature EOF on stdin");
            g27 = 0;
            exit(0);
            // UNREACHABLE
        }
    }
    int64_t v1 = (int64_t)*(int32_t *)&g14; // 0x1e09
    g28 = v1;
    int64_t v2 = 80 * v1; // 0x1e16
    int64_t result = v2 + (int64_t)&g16; // 0x1e21
    g27 = result;
    int64_t v3 = result; // 0x1e33
    int64_t v4 = -1; // 0x1e33
    int64_t v5; // 0x1e35
    while (true) {
        if (v4 == 0) {
            v5 = 0;
            // break -> bb28
            break;
        }
        int64_t v6 = (g1 ? -1 : 1) + v3; // 0x1e33
        g27 = v6;
        int64_t v7 = v4 - 1; // 0x1e33
        if (*(char *)v3 == 0) {
            v5 = v7;
            // break -> bb28
            break;
        }
        v3 = v6;
        v4 = v7;
    }
    int64_t v8 = -2 - v5; // 0x1e38
    if ((int32_t)v8 <= 78) {
        // 0x1e45
        g27 = v2;
        *(char *)((v8 + 0xffffffff & 0xffffffff) + result) = 0;
        g28 = &g15;
        *(int32_t *)&g14 = (int32_t)&g15;
        return result;
    }
    // 0x1ef0
    g27 = (int64_t)"Error: Input line too long";
    puts("Error: Input line too long");
    *(int32_t *)&g14 = (int32_t)&g15;
    int64_t v9 = 80 * (int64_t)*(int32_t *)&g14; // 0x1f0d
    g28 = 0x636e7572742a2a2a;
    g27 = 0x2a2a2a64657461;
    *(int64_t *)(v9 + (int64_t)&g16) = 0x636e7572742a2a2a;
    *(int64_t *)((int64_t)&g16 + 8 + v9) = g27;
    return explode_bomb();
}

// Address range: 0x1f3a - 0x1ffe
int64_t phase_defused(void) {
    int64_t v1 = __readfsqword(40); // 0x1f3e
    g27 = 1;
    send_msg(1);
    if (*(int32_t *)&g14 == 6) {
        // 0x1f7a
        int64_t v2; // bp-104
        int64_t v3 = &v2; // 0x1f84
        g28 = (int64_t)"%d %d %s";
        g27 = (int64_t)&g17;
        int64_t v4; // bp-108
        int64_t v5; // bp-112
        int32_t items_assigned = sscanf((char *)&g17, "%d %d %s", &v5, &v4, &v2); // 0x1f9c
        if (items_assigned == 3) {
            // 0x1fc0
            g27 = v3;
            g28 = (int64_t)"DrEvil";
            if ((int32_t)strings_not_equal(v3, "DrEvil") == 0) {
                // 0x1fd5
                g27 = (int64_t)"Curses, you've found the secret phase!";
                puts("Curses, you've found the secret phase!");
                g27 = (int64_t)"But finding it and solving it are quite different...";
                puts("But finding it and solving it are quite different...");
                secret_phase();
            }
        }
        // 0x1fa6
        g27 = (int64_t)"Congratulations! You've defused the bomb!";
        puts("Congratulations! You've defused the bomb!");
        g27 = (int64_t)"Your instructor has been notified and will verify your solution.";
        puts("Your instructor has been notified and will verify your solution.");
    }
    int64_t result = __readfsqword(40) ^ v1; // 0x1f66
    if (result == 0) {
        // 0x1f75
        return result;
    }
    // 0x1ff9
    __stack_chk_fail();
    return &g30;
}

// Address range: 0x1ffe - 0x202e
int64_t sigalrm_handler(void) {
    // 0x1ffe
    g28 = 1;
    g27 = (int64_t)g11;
    __fprintf_chk(g11, 1, "Program timed out after %d seconds\n", 0);
    g27 = 1;
    exit(1);
    return &g30;
}

// Address range: 0x202e - 0x20ea
int64_t rio_readlineb(int64_t a1, int64_t a2, int64_t a3) {
    // 0x202e
    g28 = a2;
    g27 = a1;
    int64_t v1 = g27; // 0x2036
    int64_t v2 = v1; // rbx
    int64_t v3 = g28; // r12
    int64_t v4 = 1; // r13
    int64_t buf = v1 + 16; // rbp
    int64_t v5;
    if ((a3 || 1) != 1) {
        while (true) {
            uint32_t v6 = *(int32_t *)(v1 + 4); // 0x205b
            if (v6 >= 0 == (v6 != 0)) {
                int64_t * v7 = (int64_t *)(v1 + 8); // 0x2082
                int64_t v8 = *v7; // 0x2082
                int64_t v9 = (int64_t)*(char *)v8; // rcx
                *v7 = v8 + 1;
                *(int32_t *)(v2 + 4) = (int32_t)(int64_t)v6 - 1;
                int64_t v10 = v3; // 0x2097
                v3 = v10 + 1;
                *(char *)v10 = (char)v9;
                if ((char)v9 == 10) {
                    // break -> 0x20b1
                    break;
                }
                int64_t v11 = v4 + 1 & 0xffffffff; // 0x20a5
                v4 = v11;
                if (v11 >= a3) {
                    // break -> 0x20b1
                    break;
                }
            } else {
                // 0x2062
                g28 = buf;
                uint32_t fd = *(int32_t *)&g27; // 0x206a
                g27 = fd;
                int32_t v12 = read(fd, (int64_t *)buf, 0x2000); // 0x206c
                *(int32_t *)(v2 + 4) = v12;
                int32_t v13 = v12; // 0x2074
                if (v13 < 0) {
                    // 0x2051
                    if (*__errno_location() != 4) {
                        v5 = -1;
                        goto lab_0x20d0_2;
                    }
                } else {
                    if (v13 == 0) {
                        v5 = 0;
                        goto lab_0x20d0_2;
                    }
                    // 0x207c
                    *(int64_t *)(v2 + 8) = buf;
                }
            }
            // 0x205b
            v1 = v2;
        }
    }
    goto lab_0x20b1;
  lab_0x20d0_2:;
    // 0x20d0
    int64_t result; // 0x20c1
    if ((int32_t)v5 != 0) {
        // 0x20e1
        result = -1;
        goto lab_0x20b9;
    } else {
        // 0x20d4
        if ((int32_t)v4 != 1) {
            goto lab_0x20b1;
        } else {
            result = 0;
            goto lab_0x20b9;
        }
    }
  lab_0x20b1:
    // 0x20b1
    *(char *)v3 = 0;
    result = v4;
  lab_0x20b9:
    // 0x20b9
    return result;
}

// Address range: 0x20ea - 0x292b
int64_t submitr(char * a1, int64_t a2, char * a3, int64_t a4, int64_t a5, char * a6, int64_t a7, int64_t a8, int64_t a9) {
    // 0x20ea
    g28 = a2;
    g27 = (int64_t)a1;
    g24 = g27;
    g25 = g28;
    int64_t v1 = (int64_t)a3; // 0x2100
    int64_t v2 = (int64_t)a6; // 0x210f
    char * v3 = (char *)v2; // bp-41104
    __readfsqword(40);
    g28 = 1;
    g27 = 2;
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x214e
    int64_t dest_str; // rax
    int64_t v4; // 0x224a
    int64_t v5; // 0x2436
    int64_t v6; // 0x2258
    int64_t v7; // 0x222b
    unsigned char v8; // 0x2436
    int64_t v9; // 0x24f9
    int64_t v10; // 0x2436
    if (sock_fd < 0) {
        // 0x2290
        *(int64_t *)a8 = 0x43203a726f727245;
        *(int64_t *)(a8 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(a8 + 16) = 0x206f7420656c6261;
        *(int64_t *)(a8 + 24) = 0x7320657461657263;
        *(int32_t *)(a8 + 32) = 0x656b636f;
        *(int16_t *)(a8 + 36) = 116;
        dest_str = 0xffffffff;
        goto lab_0x277a;
    } else {
        // 0x215b
        g23 = sock_fd;
        int64_t name = g24; // 0x215e
        g27 = name;
        struct hostent * v11 = gethostbyname((char *)name); // 0x2161
        int64_t v12 = (int64_t)v11; // 0x2161
        if (v11 == NULL) {
            // 0x22e0
            *(int64_t *)a8 = 0x44203a726f727245;
            *(int64_t *)(a8 + 8) = 0x6e7520736920534e;
            *(int64_t *)(a8 + 16) = 0x206f7420656c6261;
            *(int64_t *)(a8 + 24) = 0x2065766c6f736572;
            *(int64_t *)(a8 + 32) = 0x6120726576726573;
            *(int32_t *)(a8 + 40) = 0x65726464;
            *(int16_t *)(a8 + 44) = 0x7373;
            *(char *)(a8 + 46) = 0;
            g27 = g23;
            close((int32_t)g23);
            dest_str = 0xffffffff;
            goto lab_0x277a;
        } else {
            // 0x216f
            int64_t addr; // bp-41064
            int64_t v13 = &addr; // 0x216f
            g24 = v13;
            addr = 2;
            int64_t v14; // bp-41060
            g27 = &v14;
            int64_t v15 = *(int64_t *)*(int64_t *)(v12 + 24); // 0x21a5
            g28 = v15;
            __memmove_chk(&v14, (int64_t *)v15, *(int32_t *)(v12 + 20), 12);
            int64_t v16 = g25; // 0x21ad
            g25 = (int64_t)llvm_bswap_i16((int16_t)v16) | v16 & -0x10000;
            g28 = v13;
            g27 = g23;
            if (connect((int32_t)g23, (struct sockaddr *)&addr, 16) < 0) {
                // 0x234b
                *(int64_t *)a8 = 0x55203a726f727245;
                *(int64_t *)(a8 + 8) = 0x6f7420656c62616e;
                *(int64_t *)(a8 + 16) = 0x7463656e6e6f6320;
                *(int64_t *)(a8 + 24) = 0x20656874206f7420;
                *(int32_t *)(a8 + 32) = 0x76726573;
                *(int16_t *)(a8 + 36) = 0x7265;
                *(char *)(a8 + 38) = 0;
                g27 = g23;
                close((int32_t)g23);
                dest_str = 0xffffffff;
                goto lab_0x277a;
            } else {
                int64_t v17 = a7; // 0x21dd
                g27 = v17;
                int64_t v18 = -1; // 0x21e0
                int64_t v19; // 0x21e2
                while (true) {
                    if (v18 == 0) {
                        v19 = 0;
                        // break -> bb200
                        break;
                    }
                    int64_t v20 = (g1 ? -1 : 1) + v17; // 0x21e0
                    g27 = v20;
                    int64_t v21 = v18 - 1; // 0x21e0
                    if (*(char *)v17 == 0) {
                        v19 = v21;
                        // break -> bb200
                        break;
                    }
                    v17 = v20;
                    v18 = v21;
                }
                int64_t v22 = -1 - v19; // 0x21e5
                g28 = v22;
                g27 = v1;
                int64_t v23 = v1; // 0x21f0
                int64_t v24 = -1; // 0x21f0
                int64_t v25; // 0x220f
                while (true) {
                    if (v24 == 0) {
                        v25 = 0;
                        // break -> bb203
                        break;
                    }
                    int64_t v26 = (g1 ? -1 : 1) + v23; // 0x21f0
                    g27 = v26;
                    int64_t v27 = v24 - 1; // 0x21f0
                    if (*(char *)v23 == 0) {
                        v25 = v27;
                        // break -> bb203
                        break;
                    }
                    v23 = v26;
                    v24 = v27;
                }
                // bb203
                g27 = a4;
                int64_t v28 = a4; // 0x21fd
                int64_t v29 = -1; // 0x21fd
                int64_t v30; // 0x21ff
                while (true) {
                    if (v29 == 0) {
                        v30 = 0;
                        // break -> bb206
                        break;
                    }
                    int64_t v31 = (g1 ? -1 : 1) + v28; // 0x21fd
                    g27 = v31;
                    int64_t v32 = v29 - 1; // 0x21fd
                    if (*(char *)v28 == 0) {
                        v30 = v32;
                        // break -> bb206
                        break;
                    }
                    v28 = v31;
                    v29 = v32;
                }
                // bb206
                g27 = v2;
                int64_t v33 = v2; // 0x220d
                int64_t v34 = -1; // 0x220d
                int64_t v35; // 0x2212
                while (true) {
                    if (v34 == 0) {
                        v35 = 0;
                        // break -> bb209
                        break;
                    }
                    int64_t v36 = (g1 ? -1 : 1) + v33; // 0x220d
                    g27 = v36;
                    int64_t v37 = v34 - 1; // 0x220d
                    if (*(char *)v33 == 0) {
                        v35 = v37;
                        // break -> bb209
                        break;
                    }
                    v33 = v36;
                    v34 = v37;
                }
                // bb209
                if (119 - v19 + 2 * v22 + -1 - v30 - v25 - v35 < 0x2001) {
                    // 0x222b
                    int64_t v38; // bp-24648
                    v7 = &v38;
                    g27 = v7;
                    __asm_rep_stosq_memset((char *)&v38, 0, (int64_t)&g22);
                    v4 = a7;
                    g27 = v4;
                    int64_t v39 = v4; // 0x224d
                    int64_t v40 = -1; // 0x224d
                    int64_t v41; // 0x224f
                    while (true) {
                        if (v40 == 0) {
                            v41 = 0;
                            // break -> bb214
                            break;
                        }
                        int64_t v42 = v39 + (g1 ? -1 : 1); // 0x224d
                        g27 = v42;
                        int64_t v43 = v40 - 1; // 0x224d
                        if (*(char *)v39 == 0) {
                            v41 = v43;
                            // break -> bb214
                            break;
                        }
                        v39 = v42;
                        v40 = v43;
                    }
                    // bb214
                    v6 = -2 - v41;
                    int64_t v44; // 0x28b88
                    if ((int32_t)v6 != 0) {
                        // 0x2264
                        g25 = v7;
                        g24 = 0x2000000000ffd9;
                        v5 = v4;
                        while (true) {
                          lab_0x2436:
                            // 0x2436
                            v8 = *(char *)v5;
                            v10 = v8;
                            uint64_t v45 = v10 - 42; // 0x243a
                            dest_str = v45;
                            if ((char)v45 < 54) {
                                // 0x241b
                                if ((g24 & 1 << v45 % 64) == 0) {
                                    goto lab_0x2442;
                                } else {
                                    goto lab_0x2421;
                                }
                            } else {
                                goto lab_0x2442;
                            }
                        }
                      lab_0x28a3:
                        // 0x28a3
                        v44 = *(int64_t *)&v3;
                    } else {
                        v44 = v2;
                    }
                    // 0x28a3
                    int64_t v46; // bp-32840
                    int64_t buf = &v46; // 0x28a3
                    g28 = 1;
                    g27 = buf;
                    __sprintf_chk((char *)&v46, 1, 0x2000, "GET /%s/submitr.pl/?userid=%s&userpwd=%s&lab=%s&result=%s&submit=submit HTTP/1.0\r\n\r\n", (char *)v1, (char *)a4, (char *)a5, (char *)v44, &v38);
                    g27 = buf;
                    int64_t v47 = buf; // 0x28f7
                    int64_t v48 = -1; // 0x28f7
                    int64_t v49; // 0x28f9
                    while (true) {
                        if (v48 == 0) {
                            v49 = 0;
                            // break -> bb236
                            break;
                        }
                        int64_t v50 = (g1 ? -1 : 1) + v47; // 0x28f7
                        g27 = v50;
                        int64_t v51 = v48 - 1; // 0x28f7
                        if (*(char *)v47 == 0) {
                            v49 = v51;
                            // break -> bb236
                            break;
                        }
                        v47 = v50;
                        v48 = v51;
                    }
                    int64_t v52 = -2 - v49; // 0x28ff
                    int32_t v53 = v52; // 0x28ff
                    g26 = v52;
                    int64_t nbyte = 0x100000000 * v52 / 0x100000000; // 0x2907
                    g25 = nbyte;
                    g24 = buf;
                    if (v53 != 0) {
                        while (true) {
                            // 0x24ca
                            g28 = buf;
                            g27 = g23;
                            int32_t v54 = write((int32_t)g23, (int64_t *)buf, (int32_t)nbyte); // 0x24d3
                            int64_t v55; // 0x24c5
                            if (v54 >= 0 != v54 != 0) {
                                // 0x24dd
                                if (*__errno_location() != 4) {
                                    goto lab_0x261c;
                                }
                                // 0x24eb
                                v55 = 0;
                            } else {
                                v55 = v54;
                            }
                            int64_t v56 = g24 + v55; // 0x24c2
                            g24 = v56;
                            int64_t v57 = g25 - v55; // 0x24c5
                            g25 = v57;
                            if (v57 == 0) {
                                // break -> 0x24f0
                                break;
                            }
                            buf = v56;
                            nbyte = v57;
                        }
                        // 0x24f0
                        if (v53 < 0) {
                            goto lab_0x261c;
                        } else {
                            // 0x24f0
                            v9 = g29;
                            goto lab_0x24f9;
                        }
                    } else {
                        int64_t v58; // bp-41128
                        v9 = &v58;
                        goto lab_0x24f9;
                    }
                } else {
                    // 0x23a8
                    *(int64_t *)a8 = 0x52203a726f727245;
                    *(int64_t *)(a8 + 8) = 0x747320746c757365;
                    *(int64_t *)(a8 + 16) = 0x6f6f7420676e6972;
                    *(int64_t *)(a8 + 24) = 0x202e656772616c20;
                    *(int64_t *)(a8 + 32) = 0x6573616572636e49;
                    *(int64_t *)(a8 + 40) = 0x5254494d42555320;
                    *(int64_t *)(a8 + 48) = 0x46554258414d5f;
                    g27 = g23;
                    close((int32_t)g23);
                    dest_str = 0xffffffff;
                    goto lab_0x277a;
                }
            }
        }
    }
  lab_0x261c:
    // 0x261c
    *(int64_t *)a8 = 0x43203a726f727245;
    *(int64_t *)(a8 + 8) = 0x6e7520746e65696c;
    *(int64_t *)(a8 + 16) = 0x206f7420656c6261;
    *(int64_t *)(a8 + 24) = 0x6f74206574697277;
    *(int64_t *)(a8 + 32) = 0x7265732065687420;
    *(int32_t *)(a8 + 40) = 0x726576;
    g27 = g23;
    close((int32_t)g23);
    dest_str = 0xffffffff;
    goto lab_0x277a;
  lab_0x2442:;
    int32_t v135 = v8; // 0x2445
    uint32_t v136 = (v135 & 223) - 65; // 0x2448
    dest_str = v136;
    int64_t v137; // 0x24b9
    if ((char)v136 < 26) {
        goto lab_0x2421;
    } else {
        // 0x244f
        if (v8 == 32) {
            // 0x24b5
            *(char *)v7 = 43;
            v137 = g25 + 1;
            g25 = v137;
        } else {
            // 0x2455
            if ((char)(v10 - 32) >= 96) {
                // 0x245d
                if (v8 != 9) {
                    // 0x2816
                    *(int64_t *)a8 = 0x52203a726f727245;
                    *(int64_t *)(a8 + 8) = 0x747320746c757365;
                    *(int64_t *)(a8 + 16) = 0x6e6f6320676e6972;
                    *(int64_t *)(a8 + 24) = 0x6e6120736e696174;
                    *(int64_t *)(a8 + 32) = 0x6c6167656c6c6920;
                    *(int64_t *)(a8 + 40) = 0x72706e7520726f20;
                    *(int64_t *)(a8 + 48) = 0x20656c6261746e69;
                    *(int64_t *)(a8 + 56) = 0x6574636172616863;
                    *(int16_t *)(a8 + 64) = (int16_t)&g20;
                    *(char *)(a8 + 66) = 0;
                    g27 = g23;
                    close((int32_t)g23);
                    dest_str = 0xffffffff;
                    goto lab_0x277a;
                }
            }
            // 0x2467
            g28 = 1;
            char v138; // bp-8264
            g27 = &v138;
            __sprintf_chk(&v138, 1, 8, "%%%02X", v135);
            *(char *)g25 = v138;
            unsigned char v139;
            dest_str = v139;
            int64_t v140 = g25 + 3; // 0x24ac
            g25 = v140;
            v137 = v140;
        }
        goto lab_0x2429;
    }
  lab_0x2421:
    // 0x2421
    *(char *)v7 = v8;
    int64_t v141 = g25 + 1; // 0x2425
    g25 = v141;
    v137 = v141;
    goto lab_0x2429;
  lab_0x2429:;
    int64_t v142 = a7 + 1; // 0x2429
    a7 = v142;
    if (v142 == v6 + v4) {
        // break -> 0x28a3
        goto lab_0x28a3;
    }
    v7 = v137;
    v5 = v142;
    goto lab_0x2436;
  lab_0x277a:
    // 0x277a
    if ((__readfsqword(40) ^ *(int64_t *)(g29 + 0xa068)) != 0) {
        // 0x2926
        __stack_chk_fail();
        return &g30;
    }
    // 0x2791
    g25 = *(int64_t *)(g29 + 0xa080);
    g23 = *(int64_t *)(g29 + 0xa088);
    g24 = *(int64_t *)(g29 + 0xa090);
    return dest_str;
  lab_0x24f9:
    // 0x24f9
    *(int32_t *)(v9 + 80) = (int32_t)g23;
    *(int32_t *)(g29 + 84) = 0;
    int64_t v59 = g29 + 80; // 0x2506
    g27 = v59;
    *(int64_t *)(g29 + 88) = g29 + 96;
    int64_t v60 = g29 + 0x2060; // 0x2514
    g28 = v60;
    if (rio_readlineb(v59, v60, 0x2000) < 1) {
        // 0x267b
        *(int64_t *)a8 = 0x43203a726f727245;
        *(int64_t *)(a8 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(a8 + 16) = 0x206f7420656c6261;
        *(int64_t *)(a8 + 24) = 0x7269662064616572;
        *(int64_t *)(a8 + 32) = 0x6564616568207473;
        *(int64_t *)(a8 + 40) = 0x73206d6f72662072;
        *(int32_t *)(a8 + 48) = 0x65767265;
        *(int16_t *)(a8 + 52) = 114;
        g27 = g23;
        close((int32_t)g23);
        dest_str = 0xffffffff;
    } else {
        int64_t v61 = g29 + 60; // 0x252f
        int64_t v62 = g29 + 0x6060; // 0x2534
        int64_t str = g29 + 0x2060; // 0x253c
        g27 = str;
        int64_t v63 = g29 + 0x8060; // 0x2544
        g28 = (int64_t)"%s %d %[a-zA-z ]";
        sscanf((char *)str, "%s %d %[a-zA-z ]", (char **)v62, (int64_t *)v61, (int64_t *)v63);
        uint32_t v64 = *(int32_t *)(g29 + 60); // 0x255d
        if (v64 != 200) {
            int64_t v65 = g29 + 0x8060; // 0x26ef
            g28 = 1;
            g27 = a8;
            __sprintf_chk((char *)a8, 1, -1, "Error: HTTP request failed with error %d: %s", (int64_t)v64, (char *)v65);
            g27 = g23;
            close((int32_t)g23);
            dest_str = 0xffffffff;
        } else {
            // 0x256f
            g26 = g29 + 0x2060;
            g25 = (int64_t)"\r\n";
            g24 = g29 + 80;
            bool v66; // cf
            int64_t v67; // rdx
            bool v68; // zf
            while (true) {
                // 0x2583
                int64_t v69; // 0x25a2
                g28 = v69;
                int64_t v70; // 0x258b
                g27 = v70;
                bool v71; // 0x259046
                bool v72 = v71; // 0x259045
                bool v73; // 0x259043
                bool v74 = v73; // 0x259042
                int64_t v75 = v70; // 0x258e
                int64_t v76 = v69; // 0x258e
                int64_t v77 = 3; // 0x258e
                bool v78; // 0x2590
                bool v79; // 0x2593
                while (true) {
                    if (v77 == 0) {
                        v78 = v72;
                        v79 = v74;
                        // break -> bb225
                        break;
                    }
                    unsigned char v80 = *(char *)v76; // 0x258e
                    unsigned char v81 = *(char *)v75; // 0x258e
                    v66 = v80 < v81;
                    v68 = v80 == v81;
                    bool v82 = g1; // 0x258e
                    int64_t v83 = v82 ? -1 : 1; // 0x258e
                    int64_t v84 = v83 + v75; // 0x258e
                    int64_t v85 = v83 + v76; // 0x258e
                    g27 = v84;
                    g28 = v85;
                    int64_t v86 = v77 - 1; // 0x258e
                    if (v80 != v81) {
                        v78 = false;
                        v79 = v80 < v81;
                        // break -> bb225
                        break;
                    }
                    v72 = true;
                    v74 = v80 < v81;
                    v75 = v84;
                    v76 = v85;
                    v77 = v86;
                }
                unsigned char v87 = (char)!((v78 | v79)) - (char)v79; // 0x2593
                int64_t v88; // 0x2590
                dest_str = (int64_t)v87 | v88 & -256;
                v66 = false;
                v68 = v87 == 0;
                if (v87 == 0) {
                    // break -> 0x2726
                    break;
                }
                // 0x259d
                v67 = 0x2000;
                g28 = v69;
                int64_t v89 = g24; // 0x25a5
                g27 = v89;
                int64_t v90 = rio_readlineb(v89, v69, 0x2000); // 0x25a8
                dest_str = v90;
                v66 = false;
                v68 = v90 == 0;
                if (v90 >= 0 != v90 != 0) {
                    // 0x25b2
                    v67 = 0x6e7520746e65696c;
                    int64_t v91 = a8; // 0x25c6
                    *(int64_t *)v91 = 0x43203a726f727245;
                    int64_t v92 = v67; // 0x25c9
                    int64_t v93 = a8; // 0x25c9
                    *(int64_t *)(v93 + 8) = v92;
                    v67 = 0x6165682064616572;
                    int64_t v94 = a8; // 0x25e1
                    *(int64_t *)(v94 + 16) = 0x206f7420656c6261;
                    int64_t v95 = v67; // 0x25e5
                    int64_t v96 = a8; // 0x25e5
                    *(int64_t *)(v96 + 24) = v95;
                    dest_str = 0x6f72662073726564;
                    v67 = 0x726576726573206d;
                    int64_t v97 = a8; // 0x25fd
                    *(int64_t *)(v97 + 32) = 0x6f72662073726564;
                    int64_t v98 = v67; // 0x2601
                    int64_t v99 = a8; // 0x2601
                    *(int64_t *)(v99 + 40) = v98;
                    int64_t v100 = a8; // 0x2605
                    *(char *)(v100 + 48) = 0;
                    int64_t fd = g23; // 0x260a
                    g27 = fd;
                    close((int32_t)fd);
                    dest_str = 0xffffffff;
                    goto lab_0x277a;
                }
                int64_t v101 = g26;
                int64_t v102 = g25;
                v88 = v90;
                v71 = v90 == 0;
                v73 = false;
                v70 = v102;
                v69 = v101;
            }
            int64_t v103 = g29; // 0x2726
            int64_t v104 = v103 + 0x2060; // 0x2726
            g28 = v104;
            int64_t v105 = v103 + 80; // 0x272e
            g27 = v105;
            v67 = 0x2000;
            int64_t v106 = rio_readlineb(v105, v104, 0x2000); // 0x2738
            dest_str = v106;
            v66 = false;
            v68 = v106 == 0;
            if (v106 < 1) {
                // 0x27a3
                v67 = 0x6e7520746e65696c;
                int64_t v107 = a8; // 0x27b7
                *(int64_t *)v107 = 0x43203a726f727245;
                int64_t v108 = v67; // 0x27ba
                int64_t v109 = a8; // 0x27ba
                *(int64_t *)(v109 + 8) = v108;
                v67 = 0x6174732064616572;
                int64_t v110 = a8; // 0x27d2
                *(int64_t *)(v110 + 16) = 0x206f7420656c6261;
                int64_t v111 = v67; // 0x27d6
                int64_t v112 = a8; // 0x27d6
                *(int64_t *)(v112 + 24) = v111;
                v67 = 0x6d6f726620656761;
                int64_t v113 = a8; // 0x27ee
                *(int64_t *)(v113 + 32) = 0x7373656d20737574;
                int64_t v114 = v67; // 0x27f2
                int64_t v115 = a8; // 0x27f2
                *(int64_t *)(v115 + 40) = v114;
                dest_str = 0x72657672657320;
                int64_t v116 = a8; // 0x2800
                *(int64_t *)(v116 + 48) = 0x72657672657320;
                int64_t fd2 = g23; // 0x2804
                g27 = fd2;
                close((int32_t)fd2);
                dest_str = 0xffffffff;
            } else {
                int64_t v117 = g29; // 0x2742
                int64_t str3 = v117 + 0x2060; // 0x2742
                g28 = str3;
                int64_t str2 = a8; // 0x274a
                g27 = str2;
                dest_str = (int64_t)strcpy((char *)str2, (char *)str3);
                int64_t fd3 = g23; // 0x2752
                g27 = fd3;
                int32_t v118 = close((int32_t)fd3); // 0x2755
                dest_str = v118;
                g27 = (int64_t)"OK";
                int64_t v119 = a8; // 0x2766
                g28 = v119;
                int64_t v120 = (int64_t)"OK"; // 0x2769
                int64_t v121 = v119; // 0x2769
                int64_t v122 = 3; // 0x2769
                bool v123; // 0x276b
                bool v124; // 0x276e
                while (true) {
                    if (v122 == 0) {
                        // break -> ._crit_edge
                        break;
                    }
                    unsigned char v125 = *(char *)v121; // 0x2769
                    unsigned char v126 = *(char *)v120; // 0x2769
                    v66 = v125 < v126;
                    v68 = v125 == v126;
                    bool v127 = g1; // 0x2769
                    int64_t v128 = v127 ? -1 : 1; // 0x2769
                    int64_t v129 = v128 + v120; // 0x2769
                    int64_t v130 = v128 + v121; // 0x2769
                    g27 = v129;
                    g28 = v130;
                    int64_t v131 = v122 - 1; // 0x2769
                    if (v125 != v126) {
                        v123 = false;
                        v124 = v125 < v126;
                        goto lab_bb229;
                    }
                    v120 = v129;
                    v121 = v130;
                    v122 = v131;
                }
                bool v132 = v66;
                bool v133 = v68;
                v123 = v133;
                v124 = v132;
              lab_bb229:;
                int32_t v134 = (int32_t)(!((v123 | v124)) != v124) | v118 & -256; // 0x2772
                v66 = v134 != 0;
                v68 = v134 == 0;
                dest_str = -v134;
            }
        }
    }
    goto lab_0x277a;
}

// Address range: 0x292b - 0x2956
int64_t init_timeout(int64_t a1) {
    // 0x292b
    g27 = a1;
    int64_t v1 = g27; // 0x292b
    if ((int32_t)v1 == 0) {
        // 0x2954
        int64_t result; // rax
        return result;
    }
    // 0x292f
    g28 = 0x1ffe;
    g27 = 14;
    signal(SIGALARM, 0x1ffe);
    int32_t v2 = v1; // 0x2943
    uint32_t seconds = v2 >= 0 ? v2 : 0; // 0x294a
    g27 = seconds;
    return alarm(seconds);
}

// Address range: 0x2956 - 0x2b5f
int64_t init_driver(int64_t * a1) {
    // 0x2956
    g27 = (int64_t)a1;
    int64_t v1 = g23; // 0x2956
    int64_t v2 = g25; // 0x2958
    int64_t v3 = g26; // 0x2959
    int64_t addr; // bp-56
    int64_t v4 = &addr; // 0x295a
    g23 = g27;
    int64_t v5 = __readfsqword(40); // 0x2961
    g28 = 1;
    g27 = 13;
    signal(SIGPIPE, SIG_IGN);
    g28 = 1;
    g27 = 29;
    signal(SIGINFO, SIG_IGN);
    g28 = 1;
    g27 = 29;
    signal(SIGINFO, SIG_IGN);
    g28 = 1;
    g27 = 2;
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x29ad
    int64_t result; // rax
    if (sock_fd < 0) {
        // 0x2a5d
        *(int64_t *)g23 = 0x43203a726f727245;
        *(int64_t *)(g23 + 8) = 0x6e7520746e65696c;
        *(int64_t *)(g23 + 16) = 0x206f7420656c6261;
        *(int64_t *)(g23 + 24) = 0x7320657461657263;
        *(int32_t *)(g23 + 32) = 0x656b636f;
        *(int16_t *)(g23 + 36) = 116;
        result = 0xffffffff;
    } else {
        // 0x29ba
        g26 = sock_fd;
        g27 = (int64_t)"huey.cs.pdx.edu";
        struct hostent * v6 = gethostbyname("huey.cs.pdx.edu"); // 0x29c3
        int64_t v7 = (int64_t)v6; // 0x29c3
        if (v6 == NULL) {
            // 0x2ab0
            *(int64_t *)g23 = 0x44203a726f727245;
            *(int64_t *)(g23 + 8) = 0x6e7520736920534e;
            *(int64_t *)(g23 + 16) = 0x206f7420656c6261;
            *(int64_t *)(g23 + 24) = 0x2065766c6f736572;
            *(int64_t *)(g23 + 32) = 0x6120726576726573;
            *(int32_t *)(g23 + 40) = 0x65726464;
            *(int16_t *)(g23 + 44) = 0x7373;
            *(char *)(g23 + 46) = 0;
            g27 = g26;
            close((int32_t)g26);
            result = 0xffffffff;
        } else {
            // 0x29d1
            g25 = v4;
            addr = 2;
            int64_t v8; // bp-52
            g27 = &v8;
            int64_t v9 = *(int64_t *)*(int64_t *)(v7 + 24); // 0x2a01
            g28 = v9;
            __memmove_chk(&v8, (int64_t *)v9, *(int32_t *)(v7 + 20), 12);
            g28 = v4;
            g27 = g26;
            if (connect((int32_t)g26, (struct sockaddr *)&addr, 16) < 0) {
                // 0x2b22
                g28 = 1;
                g27 = g23;
                __sprintf_chk((char *)g23, 1, -1, "Error: Unable to connect to server %s", "huey.cs.pdx.edu");
                g27 = g26;
                close((int32_t)g26);
                result = 0xffffffff;
            } else {
                // 0x2a27
                g27 = g26;
                close((int32_t)g26);
                *(int16_t *)g23 = 0x4b4f;
                *(char *)(g23 + 2) = 0;
                result = 0;
            }
        }
    }
    // 0x2a40
    if (__readfsqword(40) != v5) {
        // 0x2b5a
        __stack_chk_fail();
        return &g30;
    }
    // 0x2a54
    g26 = v3;
    g25 = v2;
    g23 = v1;
    return result;
}

// Address range: 0x2b5f - 0x2bd2
int64_t driver_post(char * a1, char * a2, int64_t * a3, int64_t result2, int64_t * a5) {
    g28 = (int64_t)a2;
    int64_t v1 = (int64_t)a1;
    g27 = v1;
    int64_t v2 = g26; // 0x2b5f
    int64_t v3 = (int64_t)a5; // 0x2b60
    g26 = v3;
    if ((int32_t)result2 != 0) {
        // 0x2b7e
        g28 = (int64_t)"\nAUTORESULT_STRING=%s\n";
        g27 = 1;
        __printf_chk(1, "\nAUTORESULT_STRING=%s\n", a3);
        *(int16_t *)g26 = 0x4b4f;
        *(char *)(g26 + 2) = 0;
        // 0x2b7c
        g26 = v2;
        return 0;
    }
    if (a1 != NULL) {
        // 0x2b6c
        if (*(char *)&g27 != 0) {
            int64_t v4 = g28; // 0x2bae
            g28 = 0x3b6e;
            g27 = (int64_t)"huey.cs.pdx.edu";
            int64_t result = submitr("huey.cs.pdx.edu", 0x3b6e, "csapp", v1, v4, "spring19K", (int64_t)a3, v3, v2); // 0x2b7d
            // 0x2b7c
            g26 = v2;
            return result;
        }
    }
    // 0x2b71
    *(int16_t *)v3 = 0x4b4f;
    *(char *)(g26 + 2) = 0;
    // 0x2b7c
    g26 = v2;
    return result2;
}

// Address range: 0x2be0 - 0x2c45
int64_t __libc_csu_init(int64_t a1, int64_t a2, int64_t a3) {
    // 0x2be0
    g28 = a2;
    g27 = a1;
    int64_t result = _init(); // 0x2c0c
    if ((int64_t)&g3 - (int64_t)&g2 >> 3 != 0) {
        int64_t v1 = 0; // 0x2c2d2
        while (v1 != ((int64_t)&g3 - (int64_t)&g2 >> 3) - 1) {
            // 0x2c20
            v1++;
        }
    }
    // 0x2c36
    return result;
}

// Address range: 0x2c50 - 0x2c52
int64_t __libc_csu_fini(void) {
    // 0x2c50
    int64_t result; // rax
    return result;
}

// Address range: 0x2c54 - 0x2c5d
int64_t _fini(void) {
    // 0x2c54
    int64_t result; // rax
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// void __cxa_finalize(void * d);
// int * __errno_location(void);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void * __memmove_chk(void * dest, const void * src, size_t len, size_t dstlen);
// int __printf_chk(int flag, const char * restrict format, ...);
// int __sprintf_chk(char * restrict s, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// int connect(int fd, __CONST_SOCKADDR_ARG addr, socklen_t len);
// void exit(int status);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// char * getenv(const char * name);
// struct hostent * gethostbyname(const char * name);
// int gethostname(char * name, size_t len);
// int puts(const char * s);
// ssize_t read(int fd, void * buf, size_t nbytes);
// __sighandler_t signal(int sig, __sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// int socket(int domain, int type, int protocol);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// int strcasecmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (7.3.0)
// Detected language: C
// Detected functions: 66
// Decompilation date: 2019-05-23 01:11:40
